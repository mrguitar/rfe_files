lang en_US.UTF-8
keyboard us
timezone UTC --isUtc --ntpservers=rhel.pool.ntp.org
reboot
#work around for https://bugzilla.redhat.com/show_bug.cgi?id=1861456
text

#wipe existing drives
zerombr
clearpart --all --initlabel

#uncomment for a simple setup 
#autopart --type=plain --fstype=xfs --nohome

#this will create a fixed / and use the majority of the disk for /var
part /boot/efi --fstype=vfat --size=600
part /boot --fstype=xfs --size=1000
part swap --recommended 
part / --fstype=xfs --size 30000 --encrypted --passphrase=temppass
part /var --fstype=xfs --grow --encrypted --passphrase=temppass

network --bootproto=dhcp

#placeholder passwords are "redhat"
rootpw --iscrypted $6$3OrUXJfD.64WiZl2$4/oBFyFgIyPI6LdLCbE.h99YBrFa..pC3x3WlHNH8mUf4ssZmhlhy17CHc0n3kAvHvWecpqunVOd/4kOGB7Ms.

#work around for https://bugzilla.redhat.com/show_bug.cgi?id=1848453
services --enable=ostree-remount

#placeholder passwords are "redhat"
user --name=core --groups=wheel --iscrypted --password=$6$3OrUXJfD.64WiZl2$4/oBFyFgIyPI6LdLCbE.h99YBrFa..pC3x3WlHNH8mUf4ssZmhlhy17CHc0n3kAvHvWecpqunVOd/4kOGB7Ms.
#sshkey --username=core "ssh-rsa AAA......."

#Ensure the tar from Image Builder is served on an accessible web endpoint listed here:
ostreesetup --nogpg --osname=rhel-edge --remote=rhel-edge --url=http://192.168.81.20/ostree/repo/ --ref=rhel/8/x86_64/edge


%post

#stage updates as they become available. This is highly recommended
echo AutomaticUpdatePolicy=stage >> /etc/rpm-ostreed.conf
systemctl enable rpm-ostreed-automatic.timer

#configure clevis to unlock the luks volumes using the TPM2. Adjust /dev/vda appropriately. 
clevis luks bind -f -k- -d /dev/vda2 tpm2 '{}' \ <<<"temppass"
clevis luks bind -f -k- -d /dev/vda6 tpm2 '{}' \ <<<"temppass"

#Optional to wipe the key and only use the TPM2. 
#cryptsetup luksRemoveKey /dev/vda2 <<< "temppass"

%end

%post
#This is a simple example that will look for staged rpm-ostree updates and apply them per the timer if they exist
cat > /etc/systemd/system/applyupdate.service << EOF
[Unit]
Description=Apply Update Check

[Service]
Type=simple
ExecStart=/usr/local/sbin/applyupdatecheck.sh
EOF 

cat > /etc/systemd/system/applyupdate.timer << EOF
[Unit]
Description=Daily Update Reboot Check.

[Timer]
OnCalendar=*-*-* 01:30:00
#OnCalendar=Sun *-*-* 00:00:00

[Install]
WantedBy=multi-user.target
EOF

cat > /usr/local/sbin/applyupdatecheck.sh << EOF
#!/bin/bash

if [[ $(rpm-ostree status -v | grep "Staged: yes") ]]; then
   systemctl --message="Applying OTA update" reboot
else
   echo "Latest available update already applied"
fi
EOF

systemctl daemon-reload
systemctl enable applyupdate.timer
%end

%post
#This is an example container workload that will take advantage of Podman's new autoupdate feature
#Add the podman timer & service

cat > /etc/systemd/system/podman-auto-update.service << EOF
[Unit]
Description=Podman auto-update service
Documentation=man:podman-auto-update(1)
Wants=network.target
After=network-online.target

[Service]
ExecStart=/usr/bin/podman auto-update

[Install]
WantedBy=multi-user.target default.target
EOF

cat > /etc/systemd/system/podman-auto-update.timer << EOF
[Unit]
Description=Podman auto-update timer

[Timer]
OnCalendar=daily
Persistent=true
RandomizedDelaySec=7200

[Install]
WantedBy=timers.target
EOF

#create a unit file to run our example workload 
cat > /etc/systemd/system/container-boinc.service <<EOF
# container-boinc.service
# autogenerated by Podman 2.0.4

[Unit]
Description=Podman container-boinc.service
Documentation=man:podman-generate-systemd(1)
Wants=network.target
After=network-online.target

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
ExecStartPre=/bin/rm -f %t/container-boinc.pid %t/container-boinc.ctr-id
ExecStart=/usr/bin/podman run --conmon-pidfile %t/container-boinc.pid --cidfile %t/container-boinc.ctr-id --cgroups=no-conmon -d --replace --label io.containers.autoupdate=image --name boinc -dt -p 31416:31416 -v /opt/appdata/boinc:/var/lib/boinc:Z boinc/client:latest
ExecStop=/usr/bin/podman stop --ignore --cidfile %t/container-boinc.ctr-id -t 10
ExecStopPost=/usr/bin/podman rm --ignore -f --cidfile %t/container-boinc.ctr-id
PIDFile=%t/container-boinc.pid
KillMode=none
Type=forking

[Install]
WantedBy=multi-user.target default.target
EOF


#These steps are optional, but are useful for generating load on the device. Follow the example here: https://fedoramagazine.org/running-rosettahome-on-a-raspberry-pi-with-fedora-iot/
#create host mount points
mkdir -p /opt/appdata/boinc/slots /opt/appdata/boinc/locale
#pull & run the image
#podman run --rm --name boinc -dt -p 31416:31416 -v /opt/appdata/boinc:/var/lib/boinc:Z boinc/client:latest
#provide your account key to actually accept a workload. 
#podman exec boinc boinccmd --project_attach https://boinc.bakerlab.org/rosetta/ 2160739_cadd20314e4ef804f1d95ce2862c8f73
#podman stop boinc

systemctl daemon-reload
systemctl enable podman-auto-update.timer container-boinc.service
%end
